<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Chapter 1: Lex Luther</title>
  <link rel="stylesheet" href="/assets/style.css">
  <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<h1>Chapter 1: Lex Luther</h1>

<p>We are forming the language on the BASIC Dialect. Similar to the Syntax scope of the original article we will also do the same but maybe add a few things like some data structures.</p>

<p>Our language will allow a variety of the basic operations that you'd expect from a programming language. In particular, it will support:</p>
<ul>
  <li>Numerical variables</li>
  <li>Basic arithmetic</li>
  <li>If statements</li>
  <li>While loops</li>
  <li>Print text and numbers</li>
  <li>Input numbers</li>
  <li>Labels and goto</li>
  <li>Comments</li>
</ul>

<p>From <a href="https://austinhenley.com/blog/teenytinycompiler1.html">austinhenley.com</a></p>

<hr>

<p>In this chapter we will make a Lexer. It performs the role of taking the input and breaking it into words and identifying if it’s a keyword, identifier, space, or operator.</p>

<h2>Reading the Next Character</h2>
<img src="/assets/project1/chp1/1.png" alt="Reading character">

<h2>Peeking Ahead</h2>
<img src="/assets/project1/chp1/2.png" alt="Peeking ahead">

<p>This lets us see the next character without consuming it.</p>

<hr>

<h2>Running the Lexer</h2>
<img src="/assets/project1/chp1/3.png" alt="Running the lexer">

<p>Our class works. Now we need to make some system for classifying the tokens.</p>

<h2>Token Type Enum</h2>

<p>This feels repetitive in nature and while production-level code is usually quite a bit different, this gets the job done.</p>

<p>Java’s JIT can optimize arithmetic operations by using native CPU instructions, bringing performance closer to low-level languages like C — though we don’t manually reach the transistor level</p>

<p>Another example of optimization is seen in Python where using NumPy is faster than `A * B`. That’s because NumPy is written in C under the hood.</p>

<p>Even if we are just relabeling things like "the character `+` is to be interpreted as plus", it matters — especially in contexts where optimization has real impact. In some systems, you’d rather use a custom language.</p>

<p>We use Enums for the <code>TokenType</code> class. Enums are very compatible and optimize switch-case logic.</p>

<img src="/assets/project1/chp1/4.png" alt="Token enums">

<hr>

<h2>Whitespace & Comments</h2>

<p>In Java, unlike Python, we have to explicitly handle <code>\n</code> as part of newline detection. We add <code>\n</code> at the end of the input to simplify EOF detection.</p>

<p>Skipping comments: I imagine in Python, because everything runs as files, each line ends with `\n`, giving us consistent endings in Henley's code. Java is more console-oriented and depends on string length instead.</p>

<p>This is where we diverge. We could go with length-matching or ask the user to explicitly end lines with something like a semicolon. That would snowball into bigger differences. So instead, I just append `\n` to the string implicitly.</p>

<img src="/assets/project1/chp1/5.png" alt="Whitespace and comments">

<h2>Some More Functions and Tiny Optimizations</h2>
<img src="/assets/project1/chp1/6.png" alt="Small optimizations">

<hr>

<h2>Token Generation</h2>
<img src="/assets/project1/chp1/8.png" alt="Token generation logic">

<p>We’re nearly done — just accommodating digits and a few more things. Most of this is similar to the Python version. But translating from Python to Java requires some syntactic hoop-jumping.</p>

<h2>Final Enum Matching Example</h2>
<img src="/assets/project1/chp1/8.png" alt="Enum matching">

<hr>

<h2>Conclusion</h2>
<p>We’ve built a basic lexer that parses input, detects character types, and maps them to tokens using Enums. That’s the first building block toward a full compiler.</p>

<p><a href="/projects/project1.html">← Back to Project</a></p>

</body>
</html>
